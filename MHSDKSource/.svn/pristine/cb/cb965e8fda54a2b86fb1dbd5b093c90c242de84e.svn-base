package com.mh.sdk.util;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;    

import javax.crypto.Cipher;    
import javax.crypto.KeyGenerator;    
import javax.crypto.Mac;
import javax.crypto.SecretKey;    
import javax.crypto.spec.SecretKeySpec;    

import android.util.Base64;
   
   
public class MHEncryptUtil {
	
	public static String hmac_sha1(String key, String datas)  
        {  
            String reString = "";  
      
            try  
            {  
                byte[] data = key.getBytes("UTF-8");    
                //根据给定的字节数组构造一个密钥,第二参数指定一个密钥算法的名称     
                SecretKey secretKey = new SecretKeySpec(data, "HmacSHA1");     
                //生成一个指定 Mac 算法 的 Mac 对象     
                Mac mac = Mac.getInstance("HmacSHA1");     
                //用给定密钥初始化 Mac 对象     
                mac.init(secretKey);      
                            
                byte[] text = datas.getBytes();      
                //完成 Mac 操作      
                byte[] text1 = mac.doFinal(text);     
                         
                reString = Base64.encodeToString(text1, Base64.DEFAULT);  
      
            } catch (Exception e)  
            {  
                // TODO: handle exception   
            }  
              
            return reString;  
        }  
	
	public static String SHA1(String s) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-1");
            digest.update(s.getBytes());
            byte messageDigest[] = digest.digest();
            return toHexString(messageDigest);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return "";
    }
	
	public static String toHexString(byte[] keyData) {
        if (keyData == null) {
            return null;
        }
        int expectedStringLen = keyData.length * 2;
        StringBuilder sb = new StringBuilder(expectedStringLen);
        for (int i = 0; i < keyData.length; i++) {
            String hexStr = Integer.toString(keyData[i] & 0x00FF,16);
            if (hexStr.length() == 1) {
                hexStr = "0" + hexStr;
            }
            sb.append(hexStr);
        }
        return sb.toString();
    }
   
	public static String toMd5(String string) {
		try {
			// Create MD5 Hash
			MessageDigest digest = java.security.MessageDigest
					.getInstance("MD5");
			digest.update(string.getBytes());
			byte messageDigest[] = digest.digest();
			StringBuffer sb = new StringBuffer();
			
			for (int i = 0; i < messageDigest.length; i++) {
				int temp = 0xFF & messageDigest[i];
				String s = Integer.toHexString(temp);
				if (temp <= 0x0F) {
					s = "0" + s;
				}
				sb.append(s);
			}
			return sb.toString();
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		}

		return "";
	}
	
	/**
	 * 加密
	 * @param seed
	 * @param cleartext
	 * @return
	 * @throws Exception
	 */
    public static String encrypt(String seed, String cleartext) throws Exception {    
        byte[] rawKey = getRawKey(seed.getBytes());    
        byte[] result = encrypt(rawKey, cleartext.getBytes());    
        return toHex(result);    
    }    
        
    /**
     * 解密
     * @param seed
     * @param encrypted
     * @return
     * @throws Exception
     */
    public static String decrypt(String seed, String encrypted) throws Exception {    
        byte[] rawKey = getRawKey(seed.getBytes());    
        byte[] enc = toByte(encrypted);    
        byte[] result = decrypt(rawKey, enc);    
        return new String(result);    
    }    
   
    private static byte[] getRawKey(byte[] seed) throws Exception {    
        KeyGenerator kgen = KeyGenerator.getInstance("AES");    
        SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");    
        sr.setSeed(seed);    
        kgen.init(128, sr); // 192 and 256 bits may not be available    
        SecretKey skey = kgen.generateKey();    
        byte[] raw = skey.getEncoded();    
        return raw;    
    }    
   
        
    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {    
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");    
        Cipher cipher = Cipher.getInstance("AES");    
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);    
        byte[] encrypted = cipher.doFinal(clear);    
        return encrypted;    
    }    
   
    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {    
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");    
        Cipher cipher = Cipher.getInstance("AES");    
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);    
        byte[] decrypted = cipher.doFinal(encrypted);    
        return decrypted;    
    }    
   
    public static String toHex(String txt) {    
        return toHex(txt.getBytes());    
    }    
    public static String fromHex(String hex) {    
        return new String(toByte(hex));    
    }    
        
    public static byte[] toByte(String hexString) {    
        int len = hexString.length()/2;    
        byte[] result = new byte[len];    
        for (int i = 0; i < len; i++)    
            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();    
        return result;    
    }    
   
    public static String toHex(byte[] buf) {    
        if (buf == null)    
            return "";    
        StringBuffer result = new StringBuffer(2*buf.length);    
        for (int i = 0; i < buf.length; i++) {    
            appendHex(result, buf[i]);    
        }    
        return result.toString();    
    }    
    private final static String HEX = "0123456789ABCDEF";    
    private static void appendHex(StringBuffer sb, byte b) {    
        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));    
    }    
        
}  
